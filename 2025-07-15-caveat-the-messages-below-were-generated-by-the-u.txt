
  // 任务类型定义
  interface BaseTask {
    taskId: string;
    name: string;
    enabled: boolean;
    timestamp: number;
    description?: string;
  }

  // 本地任务（包含实际数据）
  interface LocalTask extends BaseTask {
    type: 'local';
    textContent: string[];
    settings: TaskSettings;
    actualProcessedItems?: ProcessedItems;
    metadata?: {
      vectorCount: number;
      lastVectorized: number;
      sourceHash?: string;
    };
  }

  // 外挂任务（只包含引用）
  interface ExternalTask extends BaseTask {
    type: 'external';
    reference: {
      sourceChatId: string;
      sourceTaskId: string;
      // 缓存源任务基本信息，用于快速显示
      sourceName?: string;
      sourceDescription?: string;
      lastVerified?: number;
    };
    // 本地覆盖设置
    overrides?: {
      customName?: string;
      customDescription?: string;
    };
  }

  // 统一的任务类型
  type VectorTask = LocalTask | ExternalTask;

  3. 服务层架构

  // 任务管理服务
  class TaskManagerService {
    // 任务解析器
    private taskResolver: TaskResolver;

    // 任务验证器
    private taskValidator: TaskValidator;

    // 获取任务的实际数据
    async resolveTask(task: VectorTask): Promise<ResolvedTask> {
      if (task.type === 'local') {
        return { valid: true, data: task };
      }

      // 外挂任务解析
      return await this.taskResolver.resolveExternal(task);
    }

    // 创建外挂任务
    async createExternalTask(
      targetChatId: string,
      sourceChatId: string,
      sourceTaskId: string
    ): Promise<ExternalTask> {
      // 验证源任务存在
      const sourceTask = await this.getTask(sourceChatId, sourceTaskId);
      if (!sourceTask) {
        throw new Error('Source task not found');
      }

      // 创建外挂任务
      const externalTask: ExternalTask = {
        taskId: generateTaskId(),
        type: 'external',
        name: `外挂：${sourceTask.name}`,
        enabled: true,
        timestamp: Date.now(),
        reference: {
          sourceChatId,
          sourceTaskId,
          sourceName: sourceTask.name,
          sourceDescription: sourceTask.description,
          lastVerified: Date.now()
        }
      };

      return externalTask;
    }
  }

● Update Todos
  ⎿  ☒ 设计外挂任务的核心数据结构和存储机制
     ☐ 设计外挂任务的业务逻辑和处理流程
     ☐ 设计外挂任务与向量化系统的集成
     ☐ 设计外挂任务的生命周期管理
     ☐ 设计外挂任务功能的架构设计

● 4. 业务逻辑处理

  // 任务解析器
  class TaskResolver {
    async resolveExternal(task: ExternalTask): Promise<ResolvedTask> {
      const { sourceChatId, sourceTaskId } = task.reference;

      // 尝试获取源任务
      const sourceTask = await this.taskStorage.getTask(sourceChatId, sourceTaskId);

      if (!sourceTask) {
        // 源任务不存在，返回降级信息
        return {
          valid: false,
          reason: 'source_deleted',
          fallback: {
            name: task.reference.sourceName || '源数据已删除',
            description: task.reference.sourceDescription || '原始任务已被删除'
          }
        };
      }

      // 返回解析后的任务数据
      return {
        valid: true,
        data: {
          ...sourceTask,
          // 保留外挂任务的本地设置
          taskId: task.taskId,
          name: task.overrides?.customName || task.name,
          enabled: task.enabled, // 使用外挂任务自己的启用状态
          description: task.overrides?.customDescription || sourceTask.description
        }
      };
    }
  }

  // 向量查询适配器
  class VectorQueryAdapter {
    async queryWithTask(
      task: VectorTask,
      queryText: string,
      options: QueryOptions
    ): Promise<VectorResult[]> {
      // 确定集合ID
      const collectionId = this.getCollectionId(task);

      // 执行查询
      const results = await this.storageAdapter.queryCollection(
        collectionId,
        queryText,
        options
      );

      // 添加任务元数据
      return results.map(result => ({
        ...result,
        metadata: {
          ...result.metadata,
          taskId: task.taskId,
          taskName: task.name,
          isExternal: task.type === 'external'
        }
      }));
    }

    private getCollectionId(task: VectorTask): string {
      if (task.type === 'external') {
        // 外挂任务使用源任务的集合ID
        const { sourceChatId, sourceTaskId } = task.reference;
        return `${sourceChatId}_${sourceTaskId}`;
      }
      // 本地任务使用自己的集合ID
      return `${task.chatId}_${task.taskId}`;
    }
  }

● Update Todos
  ⎿  ☒ 设计外挂任务的核心数据结构和存储机制
     ☒ 设计外挂任务的业务逻辑和处理流程
     ☐ 设计外挂任务与向量化系统的集成
     ☐ 设计外挂任务的生命周期管理
     ☐ 设计外挂任务功能的架构设计

● 5. 向量化系统集成

  // 统一的查询接口
  class UnifiedVectorQuery {
    async query(
      chatId: string,
      queryText: string,
      options: QueryOptions
    ): Promise<AggregatedResults> {
      const tasks = await this.taskManager.getChatTasks(chatId);
      const enabledTasks = tasks.filter(t => t.enabled);

      const allResults: VectorResult[] = [];

      // 并行查询所有启用的任务
      await Promise.all(
        enabledTasks.map(async (task) => {
          try {
            // 处理外挂任务的解析
            if (task.type === 'external') {
              const resolved = await this.taskResolver.resolveExternal(task);
              if (!resolved.valid) {
                console.warn(`Skipping invalid external task: ${task.name}`);
                return;
              }
            }

            // 执行查询
            const results = await this.queryAdapter.queryWithTask(
              task,
              queryText,
              options
            );

            allResults.push(...results);
          } catch (error) {
            console.error(`Failed to query task ${task.name}:`, error);
          }
        })
      );

      // 聚合和排序结果
      return this.aggregateResults(allResults);
    }
  }

  6. UI组件设计

  // 任务列表组件
  class TaskListComponent {
    render(tasks: VectorTask[]): HTMLElement {
      return tasks.map(task => {
        const element = this.createTaskElement(task);

        // 添加类型标识
        if (task.type === 'external') {
          element.classList.add('external-task');

          // 检查源数据有效性
          this.checkExternalTaskValidity(task).then(valid => {
            if (!valid) {
              element.classList.add('orphaned');
            }
          });
        }

        return element;
      });
    }

    private createTaskElement(task: VectorTask): HTMLElement {
      const controls = {
        preview: this.createPreviewButton(task),
        rename: this.createRenameButton(task),
        delete: this.createDeleteButton(task),
        toggle: this.createToggleButton(task)
      };

      // 外挂任务特殊处理
      if (task.type === 'external') {
        // 隐藏重新向量化按钮
        controls.revectorize = null;

        // 添加"查看源任务"按钮
        controls.viewSource = this.createViewSourceButton(task);
      }

      return this.assembleTaskElement(task, controls);
    }
  }

● Update Todos
  ⎿  ☒ 设计外挂任务的核心数据结构和存储机制
     ☒ 设计外挂任务的业务逻辑和处理流程
     ☒ 设计外挂任务与向量化系统的集成
     ☐ 设计外挂任务的生命周期管理
     ☐ 设计外挂任务功能的架构设计

● 7. 生命周期管理

  // 外挂任务生命周期管理
  class ExternalTaskLifecycle {
    // 创建外挂任务
    async create(params: CreateExternalTaskParams): Promise<ExternalTask> {
      // 1. 验证源任务存在
      await this.validateSource(params);

      // 2. 检查循环引用
      await this.checkCircularReference(params);

      // 3. 创建外挂任务
      const task = await this.taskManager.createExternalTask(params);

      // 4. 注册任务关系（用于追踪）
      await this.registerTaskRelation(task);

      return task;
    }

    // 源聊天删除时的处理
    async handleSourceChatDeleted(chatId: string): Promise<void> {
      const affectedTasks = await this.findExternalTasksBySource(chatId);

      for (const task of affectedTasks) {
        // 标记为孤儿任务，但不删除
        await this.markAsOrphaned(task);

        // 通知UI更新
        this.eventBus.emit('task:orphaned', task);
      }
    }

    // 定期验证外挂任务有效性
    async validateExternalTasks(): Promise<void> {
      const allExternalTasks = await this.getAllExternalTasks();

      for (const task of allExternalTasks) {
        const isValid = await this.validateTaskReference(task);

        if (!isValid && !task.orphaned) {
          await this.markAsOrphaned(task);
        } else if (isValid && task.orphaned) {
          await this.restoreFromOrphaned(task);
        }

        // 更新最后验证时间
        task.reference.lastVerified = Date.now();
      }
    }
  }

  // 事件处理
  class TaskEventHandlers {
    constructor(
      private lifecycle: ExternalTaskLifecycle,
      private eventSource: EventSource
    ) {
      this.registerHandlers();
    }

    private registerHandlers() {
      // 聊天删除事件
      this.eventSource.on('CHAT_DELETED', async (chatId) => {
        // 删除本地任务的向量数据
        await this.deleteLocalTaskVectors(chatId);

        // 处理外挂任务
        await this.lifecycle.handleSourceChatDeleted(chatId);

        // 清理任务元数据
        await this.cleanupTaskMetadata(chatId);
      });

      // 定期验证（每30分钟）
      setInterval(() => {
        this.lifecycle.validateExternalTasks();
      }, 30 * 60 * 1000);
    }
  }

● Update Todos
  ⎿  ☒ 设计外挂任务的核心数据结构和存储机制
     ☒ 设计外挂任务的业务逻辑和处理流程
     ☒ 设计外挂任务与向量化系统的集成
     ☒ 设计外挂任务的生命周期管理
     ☐ 设计外挂任务功能的架构设计

● 8. 完整的架构设计

  // 模块化架构
  export class VectorEnhancedModule {
    private taskManager: TaskManagerService;
    private queryEngine: UnifiedVectorQuery;
    private lifecycle: ExternalTaskLifecycle;
    private ui: TaskUIManager;

    async initialize() {
      // 初始化各个服务
      this.taskManager = new TaskManagerService({
        storage: new TaskStorage(),
        resolver: new TaskResolver(),
        validator: new TaskValidator()
      });

      this.queryEngine = new UnifiedVectorQuery({
        taskManager: this.taskManager,
        queryAdapter: new VectorQueryAdapter(),
        aggregator: new ResultAggregator()
      });

      this.lifecycle = new ExternalTaskLifecycle({
        taskManager: this.taskManager,
        eventBus: new EventBus()
      });

      this.ui = new TaskUIManager({
        taskList: new TaskListComponent(),
        externalTaskUI: new ExternalTaskUI(),
        previewModal: new TaskPreviewModal()
      });

      // 注册事件处理
      this.registerEventHandlers();
    }
  }

  9. 实际使用示例

  // 创建外挂任务
  async function mountExternalTask(sourceChatId, sourceTaskId) {
    const currentChatId = getCurrentChatId();

    try {
      const externalTask = await taskManager.createExternalTask({
        targetChatId: currentChatId,
        sourceChatId: sourceChatId,
        sourceTaskId: sourceTaskId
      });

      toastr.success(`成功挂载任务: ${externalTask.name}`);
      await updateTaskList();
    } catch (error) {
      toastr.error(`挂载失败: ${error.message}`);
    }
  }

  // 查询时自动处理外挂任务
  async function queryVectors(queryText) {
    const results = await queryEngine.query(
      getCurrentChatId(),
      queryText,
      { limit: 10, threshold: 0.7 }
    );

    // results 包含了本地任务和外挂任务的结果
    // 外挂任务的结果会自动从源任务的向量数据中获取
    return results;
  }

  // UI显示
  function renderTask(task) {
    if (task.type === 'external') {
      return `
        <div class="task-item external-task">
          <span class="task-icon">🔗</span>
          <span class="task-name">${task.name}</span>
          <span class="task-source">来源: ${task.reference.sourceChatId}</span>
          ${task.orphaned ? '<span class="orphaned-badge">源已删除</span>' : ''}
        </div>
      `;
    }
    // ... 渲染本地任务
  }
