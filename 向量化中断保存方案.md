# 向量化中断保存方案详细分析

## 1. 需求描述

当用户点击中断按钮后：
1. 向量化进程立即中断
2. 弹出确认对话框，显示当前进度
3. 询问是否保存已处理的内容
4. 如果选择保存，则不清理数据并创建任务
5. 如果选择不保存，则执行正常的清理流程

## 2. 技术方案分析

### 2.1 使用的对话框组件

根据代码分析，项目使用 SillyTavern 的 `callGenericPopup` 函数来创建确认对话框：

```javascript
const confirm = await callGenericPopup(
    htmlContent,          // HTML 内容
    POPUP_TYPE.CONFIRM,   // 弹窗类型
    { okButton: '是', cancelButton: '否' }  // 按钮文本
);

// 判断用户选择
if (confirm === POPUP_RESULT.AFFIRMATIVE) {
    // 用户点击了"是"
}
```

### 2.2 当前中断处理流程

位置：`index.js:1610-1620`

```javascript
if (error.message === '向量化被用户中断' || vectorizationAbortController.signal.aborted) {
    if (vectorsInserted) {
        await storageAdapter.purgeVectorIndex(collectionId);
    }
    toastr.info('向量化已中断，已清理部分数据', '中断');
    return {
        success: false,
        aborted: true,
        error: '用户中断操作'
    };
}
```

### 2.3 进度信息获取

根据代码分析，可以获取以下进度信息：
- `allProcessedChunks.length` - 已处理的总块数
- `items.length` - 原始项目数
- 当前处理批次：通过循环变量 `i` 计算

## 3. 具体修改方案

### 3.1 修改文件：`/mnt/e/Bar/SillyTavern/public/scripts/extensions/third-party/vectors-enhanced/index.js`

#### 修改点1：添加进度跟踪变量

在 `vectorizeContent` 函数开始处（约第1246行后）添加：

```javascript
// 添加进度跟踪变量
let processedChunksCount = 0;
let totalItemsCount = items.length;
```

#### 修改点2：更新进度跟踪

在批量存储循环中（约第1487行后）更新进度：

```javascript
vectorsInserted = true;
// 更新已处理的块数
processedChunksCount = Math.min(i + batch.length, allProcessedChunks.length);
```

#### 修改点3：修改中断处理逻辑

将原来的中断处理代码（第1610-1620行）替换为：

```javascript
if (error.message === '向量化被用户中断' || vectorizationAbortController.signal.aborted) {
    if (vectorsInserted) {
        // 显示确认对话框
        const confirm = await callGenericPopup(
            `<div>
                <p><strong>向量化已中断</strong></p>
                <div style="text-align: left; margin: 15px 0;">
                    <p>处理进度：</p>
                    <ul style="margin: 5px 0 15px 20px;">
                        <li>已处理块数：${processedChunksCount} / ${allProcessedChunks.length}</li>
                        <li>原始项目数：${totalItemsCount}</li>
                        <li>完成度：${Math.round((processedChunksCount / allProcessedChunks.length) * 100)}%</li>
                    </ul>
                </div>
                <p style="margin-top: 15px;">是否保存已处理的内容？</p>
                <p style="font-size: 0.9em; color: var(--SmartThemeQuoteColor);">
                    选择"是"将保留已处理的数据并创建部分完成的任务。<br>
                    选择"否"将清理所有已处理的数据。
                </p>
            </div>`,
            POPUP_TYPE.CONFIRM,
            { okButton: '是，保存', cancelButton: '否，清理' }
        );

        if (confirm === POPUP_RESULT.AFFIRMATIVE) {
            // 用户选择保存 - 创建部分完成的任务
            
            // 只保留已处理的部分
            const processedChunks = allProcessedChunks.slice(0, processedChunksCount);
            
            // 创建任务对象
            const task = {
                taskId: taskId,
                name: taskName + ' (部分完成)',
                timestamp: Date.now(),
                settings: correctedSettings,
                enabled: true,
                itemCount: processedChunks.length,
                originalItemCount: items.length,
                isIncremental: isIncremental,
                isPartial: true,  // 标记为部分完成
                completionRate: Math.round((processedChunksCount / allProcessedChunks.length) * 100),
                actualProcessedItems: actualProcessedItems,
                version: '2.0'
            };

            // 添加任务到列表
            addVectorTask(chatId, task);

            // 更新缓存
            cachedVectors.set(collectionId, {
                timestamp: Date.now(),
                hashes: processedChunks.map(chunk => chunk.hash),
                itemCount: processedChunks.length,
                settings: JSON.parse(JSON.stringify(settings)),
                isPartial: true
            });

            toastr.info(`向量化已中断，已保存 ${processedChunksCount} 个块的数据`, '部分保存');
            
            // 刷新任务列表
            await updateTaskList(getChatTasks, renameVectorTask, removeVectorTask);
            
            return {
                success: false,
                aborted: true,
                partial: true,
                savedCount: processedChunksCount,
                error: '用户中断操作（已保存部分数据）'
            };
        } else {
            // 用户选择清理
            await storageAdapter.purgeVectorIndex(collectionId);
            toastr.info('向量化已中断，已清理部分数据', '中断');
            return {
                success: false,
                aborted: true,
                error: '用户中断操作'
            };
        }
    } else {
        // 还没有插入任何数据
        toastr.info('向量化已中断', '中断');
        return {
            success: false,
            aborted: true,
            error: '用户中断操作'
        };
    }
}
```

### 3.2 可选修改：任务列表显示优化

为了更好地展示部分完成的任务，可以在任务列表中添加完成度显示。

位置：`src/ui/components/TaskList.js`

在任务项渲染时检查 `isPartial` 标志并显示完成度：

```javascript
if (task.isPartial && task.completionRate) {
    // 在任务名称后添加完成度标记
    taskName += ` (${task.completionRate}% 完成)`;
}
```

## 4. 实现要点

1. **进度准确性**：使用 `processedChunksCount` 精确跟踪已处理的块数
2. **任务标记**：使用 `isPartial` 标志标识部分完成的任务
3. **用户体验**：清晰显示进度信息和选择后果
4. **数据完整性**：确保保存的数据与实际处理的数据一致

## 5. 测试建议

1. 测试不同阶段的中断（开始时、中间、接近完成时）
2. 验证保存的数据是否可以正常查询
3. 确认任务列表正确显示部分完成状态
4. 测试后续的增量向量化是否正常工作

## 6. 注意事项

1. 所有修改都基于现有代码结构，不引入新的依赖
2. 使用项目已有的 `callGenericPopup` 和 `POPUP_TYPE.CONFIRM`
3. 保持与现有代码风格一致
4. 确保错误处理的完整性